<template>
  <div class="inline-flex relative items-center">
    <slot name="icon">
      <v-icon
        v-if="icon"
        :name="icon"
        class="absolute"
        :class="classes.icon.value"
      ></v-icon>
    </slot>

    <input
      v-model="localText"
      v-bind="$attrs"
      type="text"
      ref="reference"
      class="block w-full"
      :class="getInputClasses()"
      @input="handleInput"
      @focus="handleClickInput"
      @blur="handleBlur"
    />
    <div class="absolute flex right-0 mr-2">
      <v-spinner v-if="!noLoader" v-show="isLoading" type="svg"></v-spinner>
      <v-close-button
        v-if="clearable"
        class="ml-2"
        @click="handleClickClearButton"
      ></v-close-button>
    </div>
  </div>

  <teleport to="body">
    <transition :name="transition" @after-leave="onPopperTransitionLeave">
      <div v-if="isPopperVisible" ref="popper" class="fixed-dropdown">
        <div
          :class="classes.menu.value"
          v-detect-scroll-bottom="handlePagination"
        >
          <div
            v-if="!itemsPagination.length && !isLoading"
            :class="classes.item.value"
          >
            No data available
          </div>
          <div
            v-else
            v-for="item in itemsPagination"
            :key="item"
            :class="getItemClass(item)"
            @click="selectItem(item)"
          >
            <slot
              name="item"
              :text="getItemText(item)"
              :value="getItemValue(item)"
              :item="item"
              :highlightMatch="highlightMatch"
              :inputValue="localText"
            >
              <span v-html="getHighligtedText(item)"></span>
            </slot>
          </div>
        </div>
      </div>
    </transition>
  </teleport>
</template>

<script>
// vue
import { ref, computed, watch, toRefs } from "vue";
// composition
import useStyles from "./composition/use-styles";
import useLocalModel from "./composition/use-local-model";
import usePopper from "./composition/use-popper.js";
import useClickOutside from "./composition/use-click-outside";
// components
import vSpinner from "./vSpinner.vue";
import vCloseButton from "./vCloseButton.vue";
// directives
import detectScrollBottom from "../directives/detect-scroll-bottom";
// tools
import { isString } from "../tools";
// props
import {
  sharedPopperProps,
  sharedStyleProps,
  sharedFormProps,
} from "../shared-props";

export default {
  props: {
    modelValue: { type: [String, Object], default: undefined },
    ...sharedPopperProps({ offsetY: 10 }),
    items: { type: Array, default: [] },
    itemText: { type: String, default: "text" },
    itemValue: { type: String, default: "value" },
    filterKeys: { type: Array, default: [] },
    isLoading: { type: Boolean, default: false },
    noFilter: { type: Boolean, default: false },
    noPagination: { type: Boolean, default: false },
    noLoader: { type: Boolean, default: false },
    validate: { type: Object, default: {} },
    itemsPerPage: { type: Number, default: 10 },
    transition: { type: String, default: "fade" },
    styleAutocomplete: { type: [String, Array], default: "" },
    styleMenu: { type: [String, Array], default: "" },
    styleItem: { type: [String, Array], default: "" },
    styleMatch: { type: [String, Array], default: "" },
    styleIcon: { type: [String, Array], default: "" },
    ...sharedFormProps(null, { icon: true, clearable: true }),
    ...sharedStyleProps("autocomplete"),
  },
  components: {
    vSpinner,
    vCloseButton,
  },
  directives: {
    detectScrollBottom,
  },
  emits: [
    "update:modelValue",
    "update:page",
    "state:focus",
    "input:value",
    "state:opened",
    "state:closed",
    "validate",
  ],
  setup(props, { attrs, emit }) {
    let { classes, states, variants } = useStyles("autocomplete", props, {
      autocomplete: {
        states: ["valid", "invalid", "disabled"],
        variants: ["icon-variant", "clearable-variant"],
      },
      menu: {
        fixed: "fixed-autocomplete-menu",
      },
      item: {
        fixed: "fixed-item",
        states: ["active", "disabled"],
      },
      match: null,
      icon: null,
    });

    let getInputClasses = () => {
      return [
        classes.autocomplete.value,
        states.autocomplete.value && states.autocomplete.value[state.value],
        attrs.disabled === "" || attrs.disabled === true
          ? states.autocomplete.disabled
          : "",
        props.icon ? variants.autocomplete.value["icon-variant"] : "",
        props.clearable ? variants.autocomplete.value["clearable-variant"] : "",
      ];
    };

    let getItemClass = (item) => {
      return [
        item.disabled
          ? [classes.item.value, states.item.value.disabled]
          : classes.item.value,
      ];
    };

    let localModel = useLocalModel(props, emit);

    const { offsetX, offsetY, noFlip, placement, modelValue } = toRefs(props);
    const {
      isPopperVisible,
      reference,
      popper,
      showPopper,
      hidePopper,
      onPopperTransitionLeave,
    } = usePopper(
      { placement, offsetX, offsetY, noFlip, modelValue, emit },
      { resizePopper: true }
    );

    let { onClickOutside } = useClickOutside();
    let stopClickOutside = null

    let selectedItem = ref(null);
    let localText = ref("");
    let isNewSelection = ref(true);
    let isVisible = ref(false);

    let state = ref("")

    // show autocomplete menu

    let show = () => {
      isNewSelection.value = true;
      showPopper();
      stopClickOutside = onClickOutside(popper, cancelInput, reference);
    };

    // those watchers controls autocomplete menu visibility

    watch(
      () => props.isLoading,
      (value) => {
        !isPopperVisible.value && isVisible.value && !value && show();
      }
    );

    watch(isVisible, (value) => {
      !isPopperVisible.value && value && !props.noFilter && show();
    });

    // get text and value of item

    let getItemText = (item, key) => {
      return isString(item)
        ? item
        : item[key !== undefined ? key : props.itemText];
    };

    let getItemValue = (item) => {
      return isString(item) ? item : item[props.itemValue];
    };

    // filter items

    let itemsFiltered = computed(() => {
      if (props.isLoading || props.noFilter) return props.items;
      if (isNewSelection.value) return props.items;

      if (props.filterKeys.length) {
        return props.items.filter((item) => {
          return props.filterKeys.some((key) => {
            let i = getItemText(item, key);
            return (
              i && i.toLowerCase().indexOf(localText.value.toLowerCase()) !== -1
            );
          });
        });
      }

      return props.items.filter((item) => {
        let i = getItemText(item);
        return (
          i && i.toLowerCase().indexOf(localText.value.toLowerCase()) !== -1
        );
      });
    });

    // paginate items

    let page = ref(0);

    let itemsPagination = computed(() => {
      if (props.itemsPerPage === 0 || props.noPagination)
        return itemsFiltered.value;

      return itemsFiltered.value.slice(
        0,
        (page.value + 1) * props.itemsPerPage
      );
    });

    // matching text higlight

    let getHighligtedText = (item) => {
      return highlightMatch(getItemText(item), localText.value);
    };

    let highlightMatch = (string, match) => {
      return string.replace(
        new RegExp(`(${match})`, "i"),
        `<span class='${classes.match.value}'>$1</span>`
      );
    };

    // update local input text and model after selecting option

    let update = (item) => {
      selectedItem.value = item;
      localText.value = getItemText(item);
      localModel.value = getItemValue(item);
    };

    // revert to previous value for example after closing
    // dropdown menu without selecting option

    let revert = () => {
      if (!selectedItem.value) {
        localText.value = "";
        return;
      }
      localText.value = getItemText(selectedItem.value);
    };

    function cancelInput() {
      if (isVisible.value) isVisible.value = false;
      revert();
      hidePopper();
      if (stopClickOutside) stopClickOutside = stopClickOutside()
    }

    let selectItem = (item) => {
      if (isVisible.value) isVisible.value = false;
      update(item);
      hidePopper();
    };

    let clearInput = () => {
      localText.value = "";
      selectedItem.value = "";
      localModel.value = "";
    };

    // handle template events

    let handlePagination = () => {
      page.value++;
      emit("update:page", page.value);
    };

    let handleClickInput = () => {
      emit("state:focus");
      if (!isVisible.value) isVisible.value = true;
    };

    let handleClickClearButton = () => clearInput();

    let handleInput = () => {
      if (!isVisible.value) isVisible.value = true;
      isNewSelection.value = false;
      emit("input:value", localText.value);
    };

    return {
      classes,
      states,
      variants,
      localText,
      localModel,
      getInputClasses,
      itemsFiltered,
      itemsPagination,
      selectItem,
      getItemText,
      getItemValue,
      getHighligtedText,
      isNewSelection,
      show,
      getItemClass,
      onPopperTransitionLeave,
      page,
      highlightMatch,
      handleClickInput,
      handleClickClearButton,
      handleInput,
      handlePagination,
      isPopperVisible,
      reference,
      popper,
    };
  },
};
</script>

<style scoped>
.fixed-autocomplete-menu {
  @apply max-h-[300px] overflow-y-auto overflow-x-hidden;
}
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
